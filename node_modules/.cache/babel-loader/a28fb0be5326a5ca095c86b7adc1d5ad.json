{"ast":null,"code":"import { useRef, useState, useCallback, useEffect } from 'react';\nvar DEFAULT_ROOT_MARGIN = '0px';\nvar DEFAULT_THRESHOLD = [0]; // For more info:\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\nfunction useIntersectionObserver(args) {\n  var _args$rootMargin, _args$threshold;\n\n  var rootMargin = (_args$rootMargin = args == null ? void 0 : args.rootMargin) != null ? _args$rootMargin : DEFAULT_ROOT_MARGIN;\n  var threshold = (_args$threshold = args == null ? void 0 : args.threshold) != null ? _args$threshold : DEFAULT_THRESHOLD;\n  var nodeRef = useRef(null);\n  var rootRef = useRef(null);\n  var observerRef = useRef(null);\n\n  var _useState = useState(),\n      entry = _useState[0],\n      setEntry = _useState[1];\n\n  var unobserve = useCallback(function () {\n    // Disconnect the current observer (if there is one)\n    var currentObserver = observerRef.current;\n    currentObserver == null ? void 0 : currentObserver.disconnect();\n    observerRef.current = null;\n  }, []);\n  var observe = useCallback(function () {\n    var node = nodeRef.current;\n\n    if (node) {\n      var root = rootRef.current;\n      var options = {\n        root: root,\n        rootMargin: rootMargin,\n        threshold: threshold\n      }; // Create a observer for current \"node\" with given options.\n\n      var observer = new IntersectionObserver(function (_ref) {\n        var newEntry = _ref[0];\n        setEntry(newEntry);\n      }, options);\n      observer.observe(node);\n      observerRef.current = observer;\n    }\n  }, [rootMargin, threshold]);\n  var initializeObserver = useCallback(function () {\n    unobserve();\n    observe();\n  }, [observe, unobserve]);\n  var refCallback = useCallback(function (node) {\n    nodeRef.current = node;\n    initializeObserver();\n  }, [initializeObserver]);\n  var rootRefCallback = useCallback(function (rootNode) {\n    rootRef.current = rootNode;\n    initializeObserver();\n  }, [initializeObserver]);\n  useEffect(function () {\n    // After React 18, StrictMode unmounts and mounts components to be sure\n    // if they are resilient effects being mounted and destroyed multiple times.\n    // This a behavior to be sure nothing breaks when off-screen components\n    // can preserve their state with future React versions.\n    // So in StrictMode, React unmounts the component, clean-up of this useEffect gets triggered and\n    // we stop observing the node. But we need to start observing after component re-mounts with its preserved state.\n    // So to handle this case, we call initializeObserver here.\n    // https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode\n    initializeObserver();\n    return function () {\n      // We disconnect the observer on unmount to prevent memory leaks etc.\n      unobserve();\n    };\n  }, [initializeObserver, unobserve]);\n  return [refCallback, {\n    entry: entry,\n    rootRef: rootRefCallback\n  }];\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction useTrackVisibility(args) {\n  var _result$entry;\n\n  var _useIntersectionObser = useIntersectionObserver(args),\n      ref = _useIntersectionObser[0],\n      result = _useIntersectionObser[1];\n\n  var isVisible = Boolean((_result$entry = result.entry) == null ? void 0 : _result$entry.isIntersecting);\n\n  var _useState = useState(isVisible),\n      wasEverVisible = _useState[0],\n      setWasEverVisible = _useState[1];\n\n  useEffect(function () {\n    if (isVisible) {\n      setWasEverVisible(isVisible);\n    }\n  }, [isVisible]);\n  return [ref, _extends({}, result, {\n    isVisible: isVisible,\n    wasEverVisible: wasEverVisible\n  })];\n}\n\nexport { useIntersectionObserver, useTrackVisibility };","map":{"version":3,"mappings":"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","names":["DEFAULT_ROOT_MARGIN","DEFAULT_THRESHOLD","useIntersectionObserver","args","rootMargin","threshold","nodeRef","useRef","rootRef","observerRef","useState","entry","setEntry","unobserve","useCallback","currentObserver","current","disconnect","observe","node","root","options","observer","IntersectionObserver","newEntry","initializeObserver","refCallback","rootRefCallback","rootNode","useEffect","useTrackVisibility","ref","result","isVisible","Boolean","_result$entry","isIntersecting","wasEverVisible","setWasEverVisible"],"sources":["/Users/harry/Desktop/Websites/crazy-alpaca/node_modules/react-intersection-observer-hook/src/useIntersectionObserver.ts","/Users/harry/Desktop/Websites/crazy-alpaca/node_modules/react-intersection-observer-hook/src/useTrackVisibility.ts"],"sourcesContent":["import { useState, useCallback, useEffect, useRef } from 'react';\n\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst DEFAULT_THRESHOLD = [0];\n\n// eslint-disable-next-line no-undef\nexport type IntersectionObserverHookArgs = IntersectionObserverInit;\n\nexport type IntersectionObserverHookRefCallbackNode = Element | null;\n\nexport type IntersectionObserverHookRefCallback = (\n  node: IntersectionObserverHookRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookRootRefCallbackNode = IntersectionObserverHookArgs['root'];\n\nexport type IntersectionObserverHookRootRefCallback = (\n  node: IntersectionObserverHookRootRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookResult = [\n  IntersectionObserverHookRefCallback,\n  {\n    entry: IntersectionObserverEntry | undefined;\n    rootRef: IntersectionObserverHookRootRefCallback;\n  },\n];\n\n// For more info:\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\nfunction useIntersectionObserver(\n  args?: IntersectionObserverHookArgs,\n): IntersectionObserverHookResult {\n  const rootMargin = args?.rootMargin ?? DEFAULT_ROOT_MARGIN;\n  const threshold = args?.threshold ?? DEFAULT_THRESHOLD;\n\n  const nodeRef = useRef<IntersectionObserverHookRefCallbackNode>(null);\n  const rootRef = useRef<IntersectionObserverHookRootRefCallbackNode>(null);\n  const observerRef = useRef<IntersectionObserver | null>(null);\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const unobserve = useCallback(() => {\n    // Disconnect the current observer (if there is one)\n    const currentObserver = observerRef.current;\n    currentObserver?.disconnect();\n    observerRef.current = null;\n  }, []);\n\n  const observe = useCallback(() => {\n    const node = nodeRef.current;\n    if (node) {\n      const root = rootRef.current;\n      const options = { root, rootMargin, threshold };\n      // Create a observer for current \"node\" with given options.\n      const observer = new IntersectionObserver(([newEntry]) => {\n        setEntry(newEntry);\n      }, options);\n      observer.observe(node);\n      observerRef.current = observer;\n    }\n  }, [rootMargin, threshold]);\n\n  const initializeObserver = useCallback(() => {\n    unobserve();\n    observe();\n  }, [observe, unobserve]);\n\n  const refCallback = useCallback<IntersectionObserverHookRefCallback>(\n    (node) => {\n      nodeRef.current = node;\n      initializeObserver();\n    },\n    [initializeObserver],\n  );\n\n  const rootRefCallback = useCallback<IntersectionObserverHookRootRefCallback>(\n    (rootNode) => {\n      rootRef.current = rootNode;\n      initializeObserver();\n    },\n    [initializeObserver],\n  );\n\n  useEffect(() => {\n    // After React 18, StrictMode unmounts and mounts components to be sure\n    // if they are resilient effects being mounted and destroyed multiple times.\n    // This a behavior to be sure nothing breaks when off-screen components\n    // can preserve their state with future React versions.\n    // So in StrictMode, React unmounts the component, clean-up of this useEffect gets triggered and\n    // we stop observing the node. But we need to start observing after component re-mounts with its preserved state.\n    // So to handle this case, we call initializeObserver here.\n    // https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode\n    initializeObserver();\n    return () => {\n      // We disconnect the observer on unmount to prevent memory leaks etc.\n      unobserve();\n    };\n  }, [initializeObserver, unobserve]);\n\n  return [refCallback, { entry, rootRef: rootRefCallback }];\n}\n\nexport default useIntersectionObserver;\n","import { useEffect, useState } from 'react';\nimport useIntersectionObserver, {\n  IntersectionObserverHookArgs,\n  IntersectionObserverHookResult,\n} from './useIntersectionObserver';\n\nexport type TrackVisibilityHookArgs = IntersectionObserverHookArgs;\n\nexport type TrackVisibilityHookResult = [\n  IntersectionObserverHookResult[0],\n  IntersectionObserverHookResult[1] & {\n    isVisible: boolean;\n    wasEverVisible: boolean;\n  },\n];\n\nfunction useTrackVisibility(\n  args?: IntersectionObserverHookArgs,\n): TrackVisibilityHookResult {\n  const [ref, result] = useIntersectionObserver(args);\n  const isVisible = Boolean(result.entry?.isIntersecting);\n  const [wasEverVisible, setWasEverVisible] = useState(isVisible);\n\n  useEffect(() => {\n    if (isVisible) {\n      setWasEverVisible(isVisible);\n    }\n  }, [isVisible]);\n\n  return [ref, { ...result, isVisible, wasEverVisible }];\n}\n\nexport default useTrackVisibility;\n"]},"metadata":{},"sourceType":"module"}